<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Toqst – Simple Dino Game</title>
  <style>
    :root{
      --bg:#0f0f0f;       /* deeper than 1a1a1a for contrast */
      --panel:#1a1a1a;
      --accent:#ff4d4d;
      --muted:#888;
      --text:#f0f0f0;
    }
    html,body{height:100%;}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji","Segoe UI Emoji";
      display:grid;place-items:center;
    }
    .wrap{width:min(920px, 94vw);}
    header{display:flex;justify-content:space-between;align-items:center;margin:18px 0 10px}
    h1{font-size:18px;margin:0;color:var(--text);}
    .btns{display:flex;gap:8px;}
    button, a.btn{
      border:none;cursor:pointer;background:transparent;color:var(--accent);
      border:1px solid var(--accent);padding:8px 12px;border-radius:999px;
      text-decoration:none;font-weight:600;letter-spacing:.2px;
    }
    button:focus-visible, a.btn:focus-visible{outline:2px solid var(--accent)}.panel{
  background:var(--panel);
  border:1px solid #2a2a2a;
  border-radius:16px;
  padding:12px; 
  box-shadow:0 8px 24px rgba(0,0,0,0.35), inset 0 0 0 1px rgba(255,77,77,0.08);
}
canvas{width:100%; height:auto; display:block; border-radius:10px; background:#111;}
.hud{display:flex;justify-content:space-between;align-items:center;margin-top:8px;color:#ddd}
.score{font-variant-numeric:tabular-nums;}
.hint{color:var(--muted)}

  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Simple Dinosaur Game</h1>
      <div class="btns">
        <button id="restart" title="Restart (R)">Restart</button>
        <button id="pause" title="Pause (P)">Pause</button>
      </div>
    </header>
    <div class="panel">
      <canvas id="game" width="900" height="260" aria-label="Runner game canvas"></canvas>
      <div class="hud">
        <div class="hint">Press <strong>Space/↑/W</strong> or <strong>Tap</strong> to jump</div>
        <div class="score"><span id="score">00000</span> · HI <span id="hiscore">00000</span></div>
      </div>
    </div>
  </div>  <script>
  (()=>{
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Resize helper for crisp canvas
    function fitCanvas(){
      const cssWidth = canvas.clientWidth;
      const cssHeight = Math.round(cssWidth * (260/900));
      canvas.style.height = cssHeight + 'px';
      canvas.width = Math.round(cssWidth * DPR);
      canvas.height = Math.round(cssHeight * DPR);
      scale = canvas.width/900; // baseline logical width 900
    }

    let scale = 1; // logical->device scale factor
    window.addEventListener('resize', fitCanvas);
    fitCanvas();

    // World constants (logical units based on baseline width 900 x height 260)
    const GROUND_Y = 210; // baseline ground level
    const GRAVITY = 0.6;
    const JUMP_VY = -12.5;

    // Game state
    let running = true;
    let gameOver = false;
    let score = 0;
    let hiscore = parseInt(localStorage.getItem('toqst_dino_hi')||'0');

    const rand = (a,b)=>Math.random()*(b-a)+a;

    const player = {
      x: 70, y: GROUND_Y, w: 36, h: 44,
      vy: 0, grounded: true,
      step: 0
    };

    const obstacles = [];
    let spawnTimer = 0;

    function reset(){
      obstacles.length = 0;
      player.y = GROUND_Y; player.vy = 0; player.grounded = true; player.step = 0;
      score = 0; spawnTimer = 0; gameOver = false; running = true;
    }

    function jump(){
      if(gameOver) { reset(); return; }
      if(player.grounded){
        player.vy = JUMP_VY; player.grounded = false;
      }
    }

    // Input
    window.addEventListener('keydown', e=>{
      if(e.repeat) return;
      const k = e.key.toLowerCase();
      if(k===' '||k==='arrowup'||k==='w'){ e.preventDefault(); jump(); }
      else if(k==='r'){ reset(); }
      else if(k==='p'){ running = !running; }
      else if(k==='enter' && gameOver){ reset(); }
    });

    // Touch/Click jump
    canvas.addEventListener('pointerdown', jump);
    document.getElementById('restart').addEventListener('click', reset);
    document.getElementById('pause').addEventListener('click', ()=> running = !running);

    // Helpers
    function speed(){
      // Base speed scales slightly with score
      return 6 + Math.min(10, score/180);
    }

    function addObstacle(){
      const t = Math.random();
      if(t < 0.7){
        // small cactus
        obstacles.push({x: 920, y: GROUND_Y, w: 18, h: 36, type:'c1'});
      } else if(t < 0.9){
        // big cactus
        obstacles.push({x: 920, y: GROUND_Y, w: 26, h: 52, type:'c2'});
      } else {
        // low-flying bird (needs duck mechanic normally, here it's just mid)
        obstacles.push({x: 920, y: GROUND_Y-60, w: 32, h: 24, type:'b'});
      }
    }

    // Collision
    function collide(a,b){
      return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h);
    }

    // Drawing primitives
    function r(x,y,w,h,fill){ ctx.fillStyle = fill; ctx.fillRect(x*scale*DPR,y*scale*DPR,w*scale*DPR,h*scale*DPR); }
    function line(x1,y1,x2,y2,w,stroke){
      ctx.strokeStyle = stroke; ctx.lineWidth = w*scale*DPR;
      ctx.beginPath(); ctx.moveTo(x1*scale*DPR, y1*scale*DPR); ctx.lineTo(x2*scale*DPR, y2*scale*DPR); ctx.stroke();
    }

    function drawBackground(){
      // ground line
      line(0, GROUND_Y+player.h+6, 900, GROUND_Y+player.h+6, 2, '#333');
      // parallax dots
      ctx.globalAlpha = 0.5;
      for(let i=0;i<20;i++){
        const x = (i*50 - (score%50));
        r(x, GROUND_Y-2, 2, 2, '#2b2b2b');
      }
      ctx.globalAlpha = 1;
    }

    function drawPlayer(){
      // simple blocky dino
      const x=player.x, y=player.y, w=player.w, h=player.h;
      r(x, y, w, h, '#202020');
      // body accents
      r(x+4, y+4, w-8, h-8, '#2b2b2b');
      // eye
      r(x+w-10, y+10, 6, 6, '#111');
      r(x+w-9, y+11, 4, 4, '#fff');
      // red crest
      r(x-6, y+6, 10, 10, 'var(--accent)');
      // feet animation
      const f = Math.floor(player.step/6)%2;
      r(x+4, y+h, 10, 6, f? 'var(--accent)':'#444');
      r(x+w-14, y+h, 10, 6, f? '#444':'var(--accent)');
    }

    function drawObstacle(o){
      const col = o.type==='b' ? '#444' : 'var(--accent)';
      r(o.x, o.y, o.w, o.h, col);
      if(o.type!=='b') r(o.x+4, o.y-4, 10, 6, '#aa2727'); // thorn tip
    }

    function drawGameOver(){
      const msg = 'GAME OVER – Press Enter or Tap to Retry';
      ctx.font = Math.round(16*scale*DPR)+'px system-ui';
      ctx.textAlign='center';
      ctx.fillStyle = '#ddd';
      ctx.fillText(msg, canvas.width/2, canvas.height/2);
    }

    // UI text
    const scoreEl = document.getElementById('score');
    const hiEl = document.getElementById('hiscore');
    function syncScores(){
      scoreEl.textContent = ("00000" + Math.floor(score)).slice(-5);
      hiEl.textContent = ("00000" + Math.floor(hiscore)).slice(-5);
    }

    // Main loop
    let last = performance.now();
    function loop(now){
      const dt = Math.min(40, now-last); last = now; // clamp delta
      requestAnimationFrame(loop);
      if(!running) return;

      // update
      if(!gameOver){
        player.vy += GRAVITY;
        player.y += player.vy;
        if(player.y >= GROUND_Y){ player.y = GROUND_Y; player.vy = 0; if(!player.grounded){ player.grounded=true; } }
        player.step += speed()*dt*0.05;

        spawnTimer -= dt;
        if(spawnTimer<=0){ addObstacle(); spawnTimer = rand(600, 1200) / (1 + score/500); }
        for(let i=obstacles.length-1;i>=0;i--){
          const o = obstacles[i];
          o.x -= speed();
          if(o.x + o.w < -10) obstacles.splice(i,1);
        }

        // score
        score += dt*0.02*speed();
        if(score>hiscore){ hiscore = score; localStorage.setItem('toqst_dino_hi', String(Math.floor(hiscore))); }

        // collisions
        for(const o of obstacles){ if(collide(player,o)){ gameOver = true; break; } }
      }

      // draw
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawBackground();
      drawPlayer();
      for(const o of obstacles) drawObstacle(o);
      if(gameOver) drawGameOver();
      syncScores();
    }

    requestAnimationFrame(loop);
  })();
  </script></body>
  </html>
